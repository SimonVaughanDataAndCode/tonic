\documentclass{article}\usepackage[]{graphicx}\usepackage[]{color}
%% maxwidth is the original width if it is less than linewidth
%% otherwise use linewidth (to make sure the graphics do not exceed the margin)
\makeatletter
\def\maxwidth{ %
  \ifdim\Gin@nat@width>\linewidth
    \linewidth
  \else
    \Gin@nat@width
  \fi
}
\makeatother

\definecolor{fgcolor}{rgb}{0.345, 0.345, 0.345}
\newcommand{\hlnum}[1]{\textcolor[rgb]{0.686,0.059,0.569}{#1}}%
\newcommand{\hlstr}[1]{\textcolor[rgb]{0.192,0.494,0.8}{#1}}%
\newcommand{\hlcom}[1]{\textcolor[rgb]{0.678,0.584,0.686}{\textit{#1}}}%
\newcommand{\hlopt}[1]{\textcolor[rgb]{0,0,0}{#1}}%
\newcommand{\hlstd}[1]{\textcolor[rgb]{0.345,0.345,0.345}{#1}}%
\newcommand{\hlkwa}[1]{\textcolor[rgb]{0.161,0.373,0.58}{\textbf{#1}}}%
\newcommand{\hlkwb}[1]{\textcolor[rgb]{0.69,0.353,0.396}{#1}}%
\newcommand{\hlkwc}[1]{\textcolor[rgb]{0.333,0.667,0.333}{#1}}%
\newcommand{\hlkwd}[1]{\textcolor[rgb]{0.737,0.353,0.396}{\textbf{#1}}}%

\usepackage{framed}
\makeatletter
\newenvironment{kframe}{%
 \def\at@end@of@kframe{}%
 \ifinner\ifhmode%
  \def\at@end@of@kframe{\end{minipage}}%
  \begin{minipage}{\columnwidth}%
 \fi\fi%
 \def\FrameCommand##1{\hskip\@totalleftmargin \hskip-\fboxsep
 \colorbox{shadecolor}{##1}\hskip-\fboxsep
     % There is no \\@totalrightmargin, so:
     \hskip-\linewidth \hskip-\@totalleftmargin \hskip\columnwidth}%
 \MakeFramed {\advance\hsize-\width
   \@totalleftmargin\z@ \linewidth\hsize
   \@setminipage}}%
 {\par\unskip\endMakeFramed%
 \at@end@of@kframe}
\makeatother

\definecolor{shadecolor}{rgb}{.97, .97, .97}
\definecolor{messagecolor}{rgb}{0, 0, 0}
\definecolor{warningcolor}{rgb}{1, 0, 1}
\definecolor{errorcolor}{rgb}{1, 0, 0}
\newenvironment{knitrout}{}{} % an empty environment to be redefined in TeX

\usepackage{alltt}
\usepackage[sc]{mathpazo}
\renewcommand{\sfdefault}{lmss}
\renewcommand{\ttdefault}{lmtt}
\usepackage[T1]{fontenc}
\usepackage{geometry}
\geometry{verbose,tmargin=2.5cm,bmargin=2.5cm,lmargin=2.5cm,rmargin=2.5cm}
\setcounter{secnumdepth}{2}
\setcounter{tocdepth}{2}
\usepackage[unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=true,bookmarksopen=true,bookmarksopenlevel=2,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=false]
 {hyperref}
\hypersetup{
 pdfstartview={XYZ null null 1}}

\makeatletter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\renewcommand{\textfraction}{0.05}
\renewcommand{\topfraction}{0.8}
\renewcommand{\bottomfraction}{0.8}
\renewcommand{\floatpagefraction}{0.75}

\makeatother
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\begin{document}








The results below are generated from an R script.

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{# metropolis.R}
\hlcom{# collection of R functions for using the random walk Metropolis-Hastings}
\hlcom{# algorithm for MCMC}
\hlcom{#}
\hlcom{# See e.g. Roberts (2015) http://arxiv.org/abs/1504.01896 }
\end{alltt}
\end{kframe}
\end{knitrout}
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{# To do:}
\hlcom{#  Fix R.hat and plots to cope with 'flattened' output}
\hlcom{#}
\hlcom{#}
\end{alltt}
\end{kframe}
\end{knitrout}
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{# The MCMC routine. Metropolis-Hastings algorithm}
\hlcom{# using a Normal random walk for the proposal }
\hlcom{# distribution.}
\hlcom{#}
\hlcom{#  theta.0 - vector of starting parameter values}
\hlcom{#  cov     - covariance matrix for proposal dist.}
\hlcom{#  M       - number of parameters in theta}
\hlcom{#  N       - number of iterations to run}
\hlcom{#  accept  - counter for number of acceptances}

\hlstd{mh.mcmc} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{posterior}\hlstd{,}
                   \hlkwc{theta.0}\hlstd{,}
                   \hlkwc{nsteps} \hlstd{=} \hlnum{1E4}\hlstd{,}
                   \hlkwc{nchains} \hlstd{=} \hlnum{5}\hlstd{,}
                   \hlkwc{burn.in} \hlstd{=} \hlnum{10}\hlstd{,}
                   \hlkwc{update} \hlstd{=} \hlnum{5}\hlstd{,}
                   \hlkwc{chatter} \hlstd{=} \hlnum{1}\hlstd{,}
                   \hlkwc{cov} \hlstd{=} \hlkwa{NULL}\hlstd{,}
                   \hlkwc{thin} \hlstd{=} \hlkwa{NULL}\hlstd{,}
                   \hlkwc{merge.chains} \hlstd{=} \hlnum{TRUE}\hlstd{,}
                   \hlkwc{proposal} \hlstd{=} \hlstr{"normal"}\hlstd{,} \hlkwc{...}\hlstd{) \{}

  \hlcom{# check the input arguments}
  \hlkwa{if} \hlstd{(}\hlkwd{missing}\hlstd{(theta.0))} \hlkwd{stop}\hlstd{(}\hlstr{'Must specify theta.0 start position.'}\hlstd{)}
  \hlkwa{if} \hlstd{(}\hlkwd{missing}\hlstd{(posterior))} \hlkwd{stop}\hlstd{(}\hlstr{'Must specify name of posterior function'}\hlstd{)}
  \hlkwa{if} \hlstd{(}\hlopt{!}\hlkwd{exists}\hlstd{(}\hlstr{'posterior'}\hlstd{))}
    \hlkwd{stop}\hlstd{(}\hlstr{'The specified log density function does not exist.'}\hlstd{)}
  \hlkwa{if} \hlstd{(}\hlkwd{is.null}\hlstd{(cov))}
    \hlkwd{stop}\hlstd{(}\hlstr{'Must specify the covariance matrix (cov).'}\hlstd{)}

  \hlcom{# dimensions of the PDF}
  \hlstd{M} \hlkwb{<-} \hlkwd{length}\hlstd{(theta.0)}

  \hlcom{# ensure the number of steps, walkers, etc. are integers  }
  \hlstd{nsteps} \hlkwb{<-} \hlkwd{as.integer}\hlstd{(nsteps)}
  \hlstd{nchains} \hlkwb{<-} \hlkwd{as.integer}\hlstd{(nchains)}
  \hlstd{burn.in} \hlkwb{<-} \hlkwd{as.integer}\hlstd{(burn.in)}

  \hlcom{# prepare a working array}
  \hlstd{p.prop} \hlkwb{<-} \hlkwd{array}\hlstd{(}\hlnum{NA}\hlstd{,} \hlkwc{dim} \hlstd{= nchains)}

  \hlcom{# number of interations needed}
  \hlstd{nrows.keep} \hlkwb{<-} \hlkwd{ceiling}\hlstd{(nsteps} \hlopt{/} \hlstd{nchains)}
  \hlkwa{if} \hlstd{(nrows.keep} \hlopt{<} \hlnum{10}\hlstd{)} \hlkwd{stop}\hlstd{(}\hlstr{'Make nsteps larger'}\hlstd{)}
  \hlstd{nrows.burnin} \hlkwb{<-} \hlkwd{ceiling}\hlstd{(burn.in} \hlopt{/} \hlstd{nchains)}
  \hlstd{ncycles} \hlkwb{<-} \hlstd{nrows.keep} \hlopt{+} \hlstd{nrows.burnin}

  \hlcom{# initialise the array for output. There are two additional 'columns': The M+1}
  \hlcom{# column stores the accept/reject flag (0=rejected, 1=accepted proposal at }
  \hlcom{# each update). This is useful for tracking the acceptance rate. The M+2 }
  \hlcom{# column stores the log posterior (PDF) values at the current position of the }
  \hlcom{# chain. This saves recomputing the posterior density at the current position}
  \hlcom{# when evaluating the accept probability.}
  \hlstd{theta} \hlkwb{<-} \hlkwd{array}\hlstd{(}\hlnum{NA}\hlstd{,} \hlkwc{dim}\hlstd{=}\hlkwd{c}\hlstd{(ncycles, nchains, M}\hlopt{+}\hlnum{2}\hlstd{))}

  \hlcom{# starting locations of chains}
  \hlkwa{for} \hlstd{(j} \hlkwa{in} \hlnum{1}\hlopt{:}\hlstd{nchains) \{}
     \hlstd{z} \hlkwb{<-} \hlstd{mvtnorm}\hlopt{::}\hlkwd{rmvnorm}\hlstd{(}\hlnum{1}\hlstd{,} \hlkwc{mean} \hlstd{= theta.0,} \hlkwc{sigma} \hlstd{= cov)}
     \hlstd{theta[}\hlnum{1}\hlstd{, j,} \hlnum{1}\hlopt{:}\hlstd{M]} \hlkwb{<-} \hlstd{z}  \hlcom{# randomized start position}
     \hlstd{theta[}\hlnum{1}\hlstd{, j, M}\hlopt{+}\hlnum{1}\hlstd{]} \hlkwb{<-} \hlnum{1}  \hlcom{# accept}
     \hlstd{theta[}\hlnum{1}\hlstd{, j, M}\hlopt{+}\hlnum{2}\hlstd{]} \hlkwb{<-} \hlkwd{posterior}\hlstd{(z, ...)}
  \hlstd{\}}

  \hlcom{# loop over the chain}

  \hlkwa{for} \hlstd{(i} \hlkwa{in} \hlnum{2}\hlopt{:}\hlstd{ncycles) \{}

    \hlcom{# carry forward the previous theta value}
    \hlcom{# will over-write if update occurs}
    \hlstd{theta[i, , ]} \hlkwb{<-} \hlstd{theta[i}\hlopt{-}\hlnum{1}\hlstd{, , ]}
    \hlstd{theta[i, , M}\hlopt{+}\hlnum{1}\hlstd{]} \hlkwb{<-} \hlnum{0}

    \hlcom{# draw a value from the proposal distribution}
    \hlcom{# either Normal or Student's t distribution (df=3)}
    \hlkwa{if} \hlstd{(proposal} \hlopt{==} \hlstr{"normal"}\hlstd{) \{}
      \hlstd{z} \hlkwb{<-} \hlstd{mvtnorm}\hlopt{::}\hlkwd{rmvnorm}\hlstd{(nchains,} \hlkwc{sigma} \hlstd{= cov)}
    \hlstd{\}} \hlkwa{else} \hlstd{\{}
      \hlstd{z} \hlkwb{<-} \hlstd{mvtnorm}\hlopt{::}\hlkwd{rmvt}\hlstd{(nchains,} \hlkwc{sigma} \hlstd{= cov}\hlopt{/}\hlnum{3}\hlstd{,} \hlkwc{df} \hlstd{=} \hlnum{3}\hlstd{)}
    \hlstd{\}}
    \hlcom{# add these random vectors to the previous position}
    \hlcom{# to produce a new 'proposal' position}
    \hlstd{theta.prop} \hlkwb{<-} \hlstd{theta[i,} \hlnum{1}\hlopt{:}\hlstd{nchains,} \hlnum{1}\hlopt{:}\hlstd{M]} \hlopt{+} \hlstd{z}

    \hlcom{# now for each chain compute the log posterior density}
    \hlcom{# at the proposed position.}
    \hlkwa{for} \hlstd{(j} \hlkwa{in} \hlnum{1}\hlopt{:}\hlstd{nchains) \{}
      \hlstd{p.prop[j]} \hlkwb{<-} \hlkwd{posterior}\hlstd{(theta.prop[j, ], ...)}
    \hlstd{\}}

    \hlcom{# compute ratio of posteriors at new and old locations}
    \hlcom{#   r = p(theta.prop) / p(theta[t-1])}
    \hlcom{# in terms of the log posterior function }
    \hlcom{# this is log[p(theta.old)] - log[p(theta.new)]}
    \hlcom{# (log.r is a vector with nchains elements.)}
    \hlstd{p.pres} \hlkwb{<-} \hlstd{theta[i, , M}\hlopt{+}\hlnum{2}\hlstd{]}
    \hlstd{log.r} \hlkwb{<-} \hlstd{p.prop} \hlopt{-} \hlstd{p.pres}

    \hlcom{# decide whether or not to update theta.}
    \hlcom{# theta is updated with probability min(r,1)}
    \hlcom{# otherwise it is left as before.}
    \hlstd{r} \hlkwb{<-} \hlkwd{exp}\hlstd{(} \hlkwd{pmin}\hlstd{(log.r,} \hlnum{0}\hlstd{) )}
    \hlstd{u} \hlkwb{<-} \hlkwd{runif}\hlstd{(nchains)}
    \hlstd{mask} \hlkwb{<-} \hlstd{(r} \hlopt{>=} \hlstd{u)}
    \hlstd{theta[i, mask,} \hlnum{1}\hlopt{:}\hlstd{M]} \hlkwb{<-} \hlstd{theta.prop[mask,} \hlnum{1}\hlopt{:}\hlstd{M]}
    \hlstd{theta[i, mask, M}\hlopt{+}\hlnum{1}\hlstd{]} \hlkwb{<-} \hlnum{1}
    \hlstd{theta[i, mask, M}\hlopt{+}\hlnum{2}\hlstd{]} \hlkwb{<-} \hlstd{p.prop[mask]}

    \hlcom{# progress report to user if requested}
    \hlstd{i.count} \hlkwb{<-} \hlnum{1}
    \hlkwa{if} \hlstd{(chatter} \hlopt{>} \hlnum{0}\hlstd{) \{}
      \hlkwa{if} \hlstd{(i} \hlopt{%%} \hlstd{update} \hlopt{==} \hlnum{0}\hlstd{) \{}
        \hlstd{accept.rate} \hlkwb{<-} \hlkwd{mean}\hlstd{( theta[i.count}\hlopt{:}\hlstd{i, , M}\hlopt{+}\hlnum{1}\hlstd{],} \hlkwc{na.rm}\hlstd{=}\hlnum{TRUE} \hlstd{)}
        \hlkwd{cat}\hlstd{(}\hlstr{"\textbackslash{}r-- Cycle"}\hlstd{, i,} \hlstr{"of"}\hlstd{, ncycles,} \hlstr{". Acceptance rate:"}\hlstd{,}
            \hlkwd{signif}\hlstd{(accept.rate}\hlopt{*}\hlnum{100}\hlstd{,} \hlnum{2}\hlstd{),} \hlstr{"%"}\hlstd{)}
      \hlstd{\}}
      \hlkwa{if} \hlstd{(i} \hlopt{==} \hlstd{ncycles)} \hlkwd{cat}\hlstd{(}\hlstr{''}\hlstd{,} \hlkwc{fill}\hlstd{=}\hlnum{TRUE}\hlstd{)}
      \hlkwa{if} \hlstd{(i} \hlopt{==} \hlstd{nrows.burnin) \{}
        \hlkwd{cat}\hlstd{(}\hlstr{' - Finished burn-in'}\hlstd{,} \hlkwc{fill}\hlstd{=}\hlnum{TRUE}\hlstd{)}
        \hlstd{i.count} \hlkwb{<-} \hlstd{nrows.burnin}\hlopt{+}\hlnum{1}
      \hlstd{\}}
    \hlstd{\}}
  \hlstd{\}} \hlcom{# end of loop over i = 2, ncycles}

  \hlcom{# strip off the burn-in period and keep only nsteps }
  \hlstd{nrows} \hlkwb{<-} \hlstd{nrows.keep}
  \hlstd{theta} \hlkwb{<-} \hlstd{theta[(}\hlnum{1}\hlopt{:}\hlstd{nrows)} \hlopt{+} \hlstd{nrows.burnin, , ]}

  \hlcom{# thin the output by keeping only every few rows}
  \hlkwa{if} \hlstd{(}\hlopt{!}\hlkwd{is.null}\hlstd{(thin)) \{}
    \hlstd{nrow.keep} \hlkwb{<-} \hlkwd{floor}\hlstd{(nrows} \hlopt{/} \hlstd{thin)}
    \hlstd{mask} \hlkwb{<-} \hlstd{(}\hlnum{1}\hlopt{:}\hlstd{nrow.keep)} \hlopt{*} \hlstd{thin}
    \hlstd{theta} \hlkwb{<-} \hlstd{theta[mask, , ]}
  \hlstd{\}}

  \hlcom{# Strip off the acceptance and log(posterior) columns }
  \hlstd{accept} \hlkwb{<-} \hlstd{theta[, , M}\hlopt{+}\hlnum{1}\hlstd{]}
  \hlstd{lpost} \hlkwb{<-} \hlkwd{as.vector}\hlstd{( theta[, , M}\hlopt{+}\hlnum{2}\hlstd{])}
  \hlstd{theta} \hlkwb{<-} \hlstd{theta[, ,} \hlnum{1}\hlopt{:}\hlstd{M]}

  \hlcom{# check the acceptance rate (column M+1).}
  \hlcom{# Also strip off the log(posterior) values which are no longer needed.}
  \hlstd{accept.rate} \hlkwb{<-} \hlkwd{mean}\hlstd{(accept,} \hlkwc{na.rm} \hlstd{=} \hlnum{TRUE}\hlstd{)}
  \hlkwa{if} \hlstd{(chatter} \hlopt{>} \hlnum{0}\hlstd{) \{}
    \hlkwd{cat}\hlstd{(}\hlstr{'\textbackslash{}n-- Final acceptance rate: '}\hlstd{, accept.rate,} \hlkwc{fill} \hlstd{=} \hlnum{TRUE}\hlstd{)}
    \hlkwa{if} \hlstd{(accept.rate} \hlopt{<} \hlnum{0.05}\hlstd{) \{}
      \hlkwd{cat}\hlstd{(}\hlstr{'-- Low acceptance rate. Consider the following suggestions:'}\hlstd{,}
          \hlkwc{fill} \hlstd{=} \hlnum{TRUE}\hlstd{)}
      \hlkwd{cat}\hlstd{(}\hlstr{'-- 1. Adjust the start position: theta.0,'}\hlstd{,} \hlkwc{fill} \hlstd{=} \hlnum{TRUE}\hlstd{)}
      \hlkwd{cat}\hlstd{(}\hlstr{'-- 2. Decrease the covariance for proposal distribution.'}\hlstd{,} \hlkwc{fill} \hlstd{=} \hlnum{TRUE}
      \hlstd{)}
    \hlstd{\}}
    \hlstd{\}}

  \hlcom{# reshape the array from [nrows, M, nwalkers] to [nrows*nwalkers, M]}
  \hlcom{# so each column is one variable, each row is one sample from the M}
  \hlcom{# M-dimensional distribution.}
  \hlkwa{if} \hlstd{(merge.chains} \hlopt{==} \hlnum{TRUE}\hlstd{) \{}
    \hlstd{nrows} \hlkwb{<-} \hlkwd{dim}\hlstd{(theta)[}\hlnum{1}\hlstd{]}
    \hlstd{theta} \hlkwb{<-} \hlkwd{matrix}\hlstd{(theta,} \hlkwc{nrow} \hlstd{= nchains} \hlopt{*} \hlstd{nrows,} \hlkwc{ncol} \hlstd{= M,} \hlkwc{byrow} \hlstd{=} \hlnum{FALSE}\hlstd{)}
  \hlstd{\}}

  \hlcom{# return the final array}
  \hlkwd{return}\hlstd{(}\hlkwd{list}\hlstd{(}\hlkwc{theta} \hlstd{= theta,}
              \hlkwc{func} \hlstd{=} \hlkwd{deparse}\hlstd{(}\hlkwd{substitute}\hlstd{(posterior)),}
              \hlkwc{lpost} \hlstd{= lpost,}
              \hlkwc{method} \hlstd{=} \hlstr{"mh.mcmc"}\hlstd{,}
              \hlkwc{nchains} \hlstd{= nchains))}
\hlstd{\}}
\end{alltt}
\end{kframe}
\end{knitrout}
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{# for each parameter theta[1]...theta[M]}
\hlcom{# calculate the R.hat statistic (Gelman & Rubin 1992)}
\hlcom{# See also Gelman et al. (2004, sect 11.6)}

\hlstd{Rhat} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{theta}\hlstd{,} \hlkwc{M}\hlstd{,} \hlkwc{L}\hlstd{) \{}

  \hlstd{R.hat} \hlkwb{<-} \hlkwd{array}\hlstd{(}\hlnum{0}\hlstd{,} \hlkwc{dim}\hlstd{=M)}
  \hlkwa{for} \hlstd{(m} \hlkwa{in} \hlnum{1}\hlopt{:}\hlstd{M) \{}
    \hlstd{tj} \hlkwb{<-} \hlstd{theta[m,,]}
    \hlstd{sj} \hlkwb{<-} \hlkwd{apply}\hlstd{(tj,} \hlnum{2}\hlstd{, var)}
    \hlstd{W} \hlkwb{<-} \hlkwd{mean}\hlstd{(sj)}
    \hlstd{mj} \hlkwb{<-} \hlkwd{apply}\hlstd{(tj,} \hlnum{2}\hlstd{, mean)}
    \hlstd{B} \hlkwb{<-} \hlkwd{var}\hlstd{(mj)}\hlopt{*}\hlstd{L}
    \hlstd{v} \hlkwb{<-} \hlstd{(L}\hlopt{-}\hlnum{1}\hlstd{)}\hlopt{/}\hlstd{L}\hlopt{*}\hlstd{W} \hlopt{+} \hlstd{B}\hlopt{/}\hlstd{L}
    \hlstd{R.hat[m]} \hlkwb{<-} \hlkwd{sqrt}\hlstd{(v}\hlopt{/}\hlstd{W)}

    \hlkwd{cat}\hlstd{(}\hlstr{"-- Theta["}\hlstd{,m,}\hlstr{"] R.hat = "}\hlstd{,R.hat[m],}\hlkwc{sep}\hlstd{=}\hlstr{""}\hlstd{)}
    \hlkwa{if} \hlstd{(R.hat[m]} \hlopt{>} \hlnum{1.2}\hlstd{) \{}
      \hlkwd{cat}\hlstd{(}\hlstr{" ** High R.hat. Check results. **"}\hlstd{,}\hlkwc{fill}\hlstd{=}\hlnum{TRUE}\hlstd{)}
    \hlstd{\}} \hlkwa{else} \hlstd{\{}
      \hlkwd{cat}\hlstd{(}\hlstr{" -- Good R.hat."}\hlstd{,} \hlkwc{fill}\hlstd{=}\hlnum{TRUE}\hlstd{)}
    \hlstd{\}}
  \hlstd{\}}
  \hlkwd{return}\hlstd{(R.hat)}
\hlstd{\}}
\end{alltt}
\end{kframe}
\end{knitrout}
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{# Perform checks for convergence of multiple}
\hlcom{# Markov chains. Uses Gelman & Rubin's R.hat}
\hlcom{# for each parameter, and also a visual check of}
\hlcom{# the 80% regions for each parameter.}

\hlstd{mcmc.conv} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{theta}\hlstd{,} \hlkwc{M}\hlstd{,} \hlkwc{L}\hlstd{,} \hlkwc{J}\hlstd{) \{}

  \hlkwd{layout}\hlstd{(}\hlkwd{t}\hlstd{(}\hlkwd{c}\hlstd{(}\hlnum{1}\hlstd{,}\hlnum{2}\hlstd{)),} \hlkwc{widths}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{0.3}\hlstd{,}\hlnum{0.7}\hlstd{))}

  \hlcom{# Calculate R.hat (Gelman & Rubin 1992) for each}
  \hlcom{# parameter as a check for convergence of chains}

  \hlstd{R.hat} \hlkwb{<-} \hlkwd{Rhat}\hlstd{(theta, M, L)}

  \hlcom{# plot the R.hat results}

  \hlkwd{plot}\hlstd{(R.hat,} \hlnum{1}\hlopt{:}\hlstd{M,} \hlkwc{xlim}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{1}\hlstd{,}\hlnum{2}\hlstd{),} \hlkwc{ylim}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{0.5}\hlstd{,M}\hlopt{+}\hlnum{0.5}\hlstd{),} \hlkwc{bty}\hlstd{=}\hlstr{"n"}\hlstd{,} \hlkwc{pch}\hlstd{=}\hlnum{16}\hlstd{,} \hlkwc{yaxp}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{1}\hlstd{,M,M}\hlopt{-}\hlnum{1}\hlstd{),}
       \hlkwc{xlab}\hlstd{=}\hlstr{"R.hat"}\hlstd{,} \hlkwc{ylab}\hlstd{=}\hlstr{"Parameter"}\hlstd{)}
  \hlkwd{abline}\hlstd{(}\hlkwc{v}\hlstd{=}\hlnum{1.1}\hlstd{,} \hlkwc{lty}\hlstd{=}\hlnum{2}\hlstd{)}
  \hlkwd{axis}\hlstd{(}\hlnum{3}\hlstd{)}

  \hlcom{# for each parameter theta[1]...theta[M]}
  \hlcom{# calculate and plot the 80% intervals from each chain}

  \hlkwd{plot}\hlstd{(}\hlkwd{rep}\hlstd{(}\hlnum{0}\hlstd{,M}\hlopt{+}\hlnum{1}\hlstd{),} \hlnum{1}\hlopt{:}\hlstd{(M}\hlopt{+}\hlnum{1}\hlstd{),} \hlkwc{ylim}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{0.5}\hlstd{,M}\hlopt{+}\hlnum{0.5}\hlstd{),} \hlkwc{xlim}\hlstd{=}\hlkwd{c}\hlstd{(}\hlopt{-}\hlnum{2}\hlstd{,}\hlnum{2}\hlstd{),} \hlkwc{type}\hlstd{=}\hlstr{"n"}\hlstd{,} \hlkwc{bty}\hlstd{=}\hlstr{"n"}\hlstd{,}
       \hlkwc{ylab}\hlstd{=}\hlstr{"Parameter"}\hlstd{,} \hlkwc{xlab}\hlstd{=}\hlstr{"80% region (scaled)"}\hlstd{,} \hlkwc{yaxp}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{1}\hlstd{,M,M}\hlopt{-}\hlnum{1}\hlstd{))}
  \hlkwd{axis}\hlstd{(}\hlnum{3}\hlstd{)}

  \hlkwa{for} \hlstd{(m} \hlkwa{in} \hlnum{1}\hlopt{:}\hlstd{M) \{}
    \hlstd{tj} \hlkwb{<-} \hlstd{theta[m,,]}
    \hlstd{intv} \hlkwb{<-} \hlkwd{apply}\hlstd{(tj,} \hlnum{2}\hlstd{, quantile,} \hlkwc{prob}\hlstd{=}\hlkwd{c}\hlstd{(}\hlnum{0.1}\hlstd{,}\hlnum{0.9}\hlstd{))}
    \hlstd{ci0} \hlkwb{<-} \hlstd{intv[}\hlnum{1}\hlstd{,]}
    \hlstd{ci1} \hlkwb{<-} \hlstd{intv[}\hlnum{2}\hlstd{,]}
    \hlstd{mt} \hlkwb{<-} \hlkwd{apply}\hlstd{(tj,} \hlnum{2}\hlstd{, mean)}
    \hlstd{scale} \hlkwb{<-} \hlkwd{mean}\hlstd{(ci1}\hlopt{-}\hlstd{ci0)}\hlopt{/}\hlnum{2}
    \hlstd{offset} \hlkwb{<-} \hlkwd{mean}\hlstd{(mt)}
    \hlstd{ci0} \hlkwb{<-} \hlstd{(ci0} \hlopt{-} \hlstd{offset)}\hlopt{/}\hlstd{scale}
    \hlstd{ci1} \hlkwb{<-} \hlstd{(ci1} \hlopt{-} \hlstd{offset)}\hlopt{/}\hlstd{scale}
    \hlkwa{for} \hlstd{(j} \hlkwa{in} \hlnum{1}\hlopt{:}\hlstd{J) \{}
      \hlstd{x} \hlkwb{<-} \hlstd{m} \hlopt{+} \hlstd{(j}\hlopt{-}\hlnum{1}\hlstd{)}\hlopt{/}\hlstd{J}\hlopt{/}\hlnum{4}
      \hlkwd{segments}\hlstd{(ci0[j], x,ci1[j], x,} \hlkwc{col}\hlstd{=j)}
    \hlstd{\}}
  \hlstd{\}}

\hlstd{\}}
\end{alltt}
\end{kframe}
\end{knitrout}

The R session information (including the OS info, R version and all
packages used):

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{sessionInfo}\hlstd{()}
\end{alltt}
\begin{verbatim}
## R version 3.2.2 (2015-08-14)
## Platform: x86_64-w64-mingw32/x64 (64-bit)
## Running under: Windows 8 x64 (build 9200)
## 
## locale:
## [1] LC_COLLATE=English_United Kingdom.1252  LC_CTYPE=English_United Kingdom.1252   
## [3] LC_MONETARY=English_United Kingdom.1252 LC_NUMERIC=C                           
## [5] LC_TIME=English_United Kingdom.1252    
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
## [1] knitr_1.12.3
## 
## loaded via a namespace (and not attached):
## [1] magrittr_1.5  formatR_1.2.1 tools_3.2.2   stringi_1.0-1 highr_0.5.1   stringr_1.0.0
## [7] evaluate_0.8
\end{verbatim}
\begin{alltt}
\hlkwd{Sys.time}\hlstd{()}
\end{alltt}
\begin{verbatim}
## [1] "2016-07-13 08:17:17 BST"
\end{verbatim}
\end{kframe}
\end{knitrout}


\end{document}
