\documentclass{article}\usepackage[]{graphicx}\usepackage[]{color}
%% maxwidth is the original width if it is less than linewidth
%% otherwise use linewidth (to make sure the graphics do not exceed the margin)
\makeatletter
\def\maxwidth{ %
  \ifdim\Gin@nat@width>\linewidth
    \linewidth
  \else
    \Gin@nat@width
  \fi
}
\makeatother

\definecolor{fgcolor}{rgb}{0.345, 0.345, 0.345}
\newcommand{\hlnum}[1]{\textcolor[rgb]{0.686,0.059,0.569}{#1}}%
\newcommand{\hlstr}[1]{\textcolor[rgb]{0.192,0.494,0.8}{#1}}%
\newcommand{\hlcom}[1]{\textcolor[rgb]{0.678,0.584,0.686}{\textit{#1}}}%
\newcommand{\hlopt}[1]{\textcolor[rgb]{0,0,0}{#1}}%
\newcommand{\hlstd}[1]{\textcolor[rgb]{0.345,0.345,0.345}{#1}}%
\newcommand{\hlkwa}[1]{\textcolor[rgb]{0.161,0.373,0.58}{\textbf{#1}}}%
\newcommand{\hlkwb}[1]{\textcolor[rgb]{0.69,0.353,0.396}{#1}}%
\newcommand{\hlkwc}[1]{\textcolor[rgb]{0.333,0.667,0.333}{#1}}%
\newcommand{\hlkwd}[1]{\textcolor[rgb]{0.737,0.353,0.396}{\textbf{#1}}}%

\usepackage{framed}
\makeatletter
\newenvironment{kframe}{%
 \def\at@end@of@kframe{}%
 \ifinner\ifhmode%
  \def\at@end@of@kframe{\end{minipage}}%
  \begin{minipage}{\columnwidth}%
 \fi\fi%
 \def\FrameCommand##1{\hskip\@totalleftmargin \hskip-\fboxsep
 \colorbox{shadecolor}{##1}\hskip-\fboxsep
     % There is no \\@totalrightmargin, so:
     \hskip-\linewidth \hskip-\@totalleftmargin \hskip\columnwidth}%
 \MakeFramed {\advance\hsize-\width
   \@totalleftmargin\z@ \linewidth\hsize
   \@setminipage}}%
 {\par\unskip\endMakeFramed%
 \at@end@of@kframe}
\makeatother

\definecolor{shadecolor}{rgb}{.97, .97, .97}
\definecolor{messagecolor}{rgb}{0, 0, 0}
\definecolor{warningcolor}{rgb}{1, 0, 1}
\definecolor{errorcolor}{rgb}{1, 0, 0}
\newenvironment{knitrout}{}{} % an empty environment to be redefined in TeX

\usepackage{alltt}
\usepackage[sc]{mathpazo}
\renewcommand{\sfdefault}{lmss}
\renewcommand{\ttdefault}{lmtt}
\usepackage[T1]{fontenc}
\usepackage{geometry}
\geometry{verbose,tmargin=2.5cm,bmargin=2.5cm,lmargin=2.5cm,rmargin=2.5cm}
\setcounter{secnumdepth}{2}
\setcounter{tocdepth}{2}
\usepackage[unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=true,bookmarksopen=true,bookmarksopenlevel=2,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=false]
 {hyperref}
\hypersetup{
 pdfstartview={XYZ null null 1}}

\makeatletter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\renewcommand{\textfraction}{0.05}
\renewcommand{\topfraction}{0.8}
\renewcommand{\bottomfraction}{0.8}
\renewcommand{\floatpagefraction}{0.75}

\makeatother
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\begin{document}



\title{\title{\title{\title{\title{\title{}}}}}}

\author{\author{\author{\author{\author{%
\thanks{This report is automatically generated with the R package \textbf{knitr}
        (version 1.12.3).}}%
\thanks{This report is automatically generated with the R package \textbf{knitr}
        (version 1.12.3).}}%
\thanks{This report is automatically generated with the R package \textbf{knitr}
        (version 1.12.3).}}%
\thanks{This report is automatically generated with the R package \textbf{knitr}
        (version 1.12.3).}}%
\thanks{This report is automatically generated with the R package \textbf{knitr}
        (version 1.12.3).}}

\maketitle
The results below are generated from an R script.

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{# gwmcmc.R}
\hlcom{# collection of R functions for using the Goodman & Weare (2010) ensemble MCMC}
\hlcom{# method. For details see: }
\hlcom{# J. Goodman & J. Weare, 2010, Ensemble samplers with affine invariance, }
\hlcom{#           CAMCOS, v5, pp65-80 }
\hlcom{# F. Hou, J. Goodman, D. Hogg, J. Weare, C. Schwab, 2012, ApJ, v745, 198 }
\hlcom{# D. Foreman-Mackey, 2013, PASJ (http://arxiv.org/abs/1202.3665)}
\end{alltt}
\end{kframe}
\end{knitrout}
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{gw.mcmc} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{posterior}\hlstd{,}
                    \hlkwc{theta.0}\hlstd{,}
                    \hlkwc{nsteps} \hlstd{=} \hlnum{1E4}\hlstd{,}
                    \hlkwc{nwalkers} \hlstd{=} \hlnum{100}\hlstd{,}
                    \hlkwc{burn.in} \hlstd{=} \hlnum{2E3}\hlstd{,}
                    \hlkwc{update} \hlstd{=} \hlnum{5}\hlstd{,}
                    \hlkwc{chatter} \hlstd{=} \hlnum{1}\hlstd{,}
                    \hlkwc{thin} \hlstd{=} \hlkwa{NULL}\hlstd{,}
                    \hlkwc{scale.init} \hlstd{=} \hlkwa{NULL}\hlstd{,}
                    \hlkwc{cov.init} \hlstd{=} \hlkwa{NULL}\hlstd{,}
                    \hlkwc{walk.rate} \hlstd{=} \hlnum{0}\hlstd{,}
                    \hlkwc{atune} \hlstd{=} \hlnum{2.0}\hlstd{,}
                    \hlkwc{stune} \hlstd{=} \hlkwa{NULL}\hlstd{,}
                    \hlkwc{merge.walkers} \hlstd{=} \hlnum{TRUE}\hlstd{,} \hlkwc{...}\hlstd{) \{}

\hlcom{# gw.mcmc - Ensemble Markov Chain Monte Carlo sampler}
\hlcom{# Inputs: }
\hlcom{#   posterior  - (function) name of the log(densiy) function to sampling from}
\hlcom{#   theta.0    - (vector) initial values of the M variables}
\hlcom{#   nsteps     - (integer) total number of samples required}
\hlcom{#   nwalkers   - (integer) number of 'walkers' (default: 100; should be > M)}
\hlcom{#   burn.in    - (integer) the 'burn-in' period for the walkers}
\hlcom{#   update     - (integer) print a progress update after <update> steps}
\hlcom{#   chatter    - (integer) how verbose is the output? }
\hlcom{#                   (0=quiet, 1=normal, 2=verbose)}
\hlcom{#   atune      - (float) set the scale size of the random jumps (default: 2.0)}
\hlcom{#   thin       - (integer) keep only every <thin> sample}
\hlcom{#   scale.init - (float) variances for randomising walkers' start positions }
\hlcom{#   cov.init   - (matrix) specify exact covariance matrix for randomising }
\hlcom{#                    walkers' start positions }
\hlcom{#   merge.walkers - TRUE/FALSE combine output from all walkers into one}
\hlcom{#   walk.rate  - Fraction of moves (0-1) to make use of the "walk move" }
\hlcom{#                 (default: NULL)}
\hlcom{#   ...        - (anything else) other arguments needed for posterior function}
\hlcom{#}
\hlcom{# Value:}
\hlcom{#  A list with components}
\hlcom{#   theta     - (array) <nsteps> samples from M-dimensional posterior }
\hlcom{#                 [nsteps rows, M columns]}
\hlcom{#   func      - (string) name of posterior function sampled}
\hlcom{#   lpost     - (vector) nsteps values of the LogPosterior density at each }
\hlcom{#                 sample position }
\hlcom{#   method    - sampling method uses (=gwmcmc)}
\hlcom{#   Nwalkers  - number of walkers used}
\hlcom{#}
\hlcom{# Description:}
\hlcom{# A simple implementation of the ensemble MCMC sampler proposed by Goodman & }
\hlcom{# Weare (2010). Given some function to compute the log of an (un-normalised) }
\hlcom{# M-dimensional posterior density function (PDF) this will produce <nsteps> }
\hlcom{# samples of M-dimensional vectors drawn from the PDF.}
\hlcom{# }
\hlcom{# It works by running a number <nwalkers> of 'walkers' through the M-dimensional}
\hlcom{# space. At initialisation, all walkers begin near some start point (specified }
\hlcom{# by theta.0) but have their positions randomised (using a multivariate normal }
\hlcom{# distribution). The ensemble of walkers then updates each cycle. The updating }
\hlcom{# is done by the 'stretch move'. The stretch move is handled by seperate }
\hlcom{# function (stretch.move).}
\hlcom{# }
\hlcom{# There is an initial period (called the 'burn-in' period) of <burn.in> cycles }
\hlcom{# that from the beginning of the chain that is discarded. This is to help remove}
\hlcom{# memory of the start positions. After a few cycles the ensemble should have }
\hlcom{# found regions of high posterior density even if started from a region of low }
\hlcom{# density.}
\hlcom{# }
\hlcom{# The chain is then run until there are at least <nsteps> total samples. Each }
\hlcom{# cycle produces <nwalkers> samples (one from each walker). So we run for nrows }
\hlcom{# = ceiling(nsteps/nwalkers) cycles after the burn-in period. Any extra cycles }
\hlcom{# can be discarded.}
\hlcom{# }
\hlcom{# The user has the option to 'thin' the output. This involves keeping only a }
\hlcom{# subset of the full chain. If <thin> is equal to 5 then we keep only every 5th }
\hlcom{# cycle. This helps remove autocorrelation between successive cycles. But modern}
\hlcom{# MCMC practice would advice against this as it throws away perfectly good }
\hlcom{# samples.}
\hlcom{# }
\hlcom{# Once we have enough samples the output from all walkers is merged into a}
\hlcom{# single nsteps (rows) * M (columns) array.}
\hlcom{#}
\hlcom{# History:}
\hlcom{#  04/04/16 - v0.1 - First working version}
\hlcom{#  14/04/16 - v0.2 - Added walk.move as an optional update step}
\hlcom{#  28/04/16 - v0.3 - Added saetfy checks, fixed sqrt(S) error in }
\hlcom{#                     walk move, reflow comments}
\hlcom{#  11/07/16 - v0.4 - Changed output to a list with additional information}
\hlcom{#}
\hlcom{# Simon Vaughan, University of Leicester}
\hlcom{# Copyright (C) 2016 Simon Vaughan}

  \hlcom{# check the input arguments}
  \hlkwa{if} \hlstd{(}\hlkwd{missing}\hlstd{(theta.0))} \hlkwd{stop}\hlstd{(}\hlstr{'Must specify theta.0 start position.'}\hlstd{)}
  \hlkwa{if} \hlstd{(}\hlkwd{missing}\hlstd{(posterior))} \hlkwd{stop}\hlstd{(}\hlstr{'Must specify name of posterior function'}\hlstd{)}
  \hlkwa{if} \hlstd{(}\hlopt{!}\hlkwd{exists}\hlstd{(}\hlstr{'posterior'}\hlstd{))}
    \hlkwd{stop}\hlstd{(}\hlstr{'The specified log density function does not exist.'}\hlstd{)}

  \hlcom{# dimensions of the PDF}
  \hlstd{M} \hlkwb{<-} \hlkwd{length}\hlstd{(theta.0)}

  \hlcom{# number of 'walkers'}
  \hlkwa{if} \hlstd{(nwalkers} \hlopt{<=} \hlstd{M)} \hlkwd{stop}\hlstd{(}\hlstr{'Increase the number of walkers.'}\hlstd{)}

  \hlcom{# ensure the number of steps, walkers, etc. are integers  }
  \hlstd{nsteps} \hlkwb{<-} \hlkwd{as.integer}\hlstd{(nsteps)}
  \hlstd{nwalkers} \hlkwb{<-} \hlkwd{as.integer}\hlstd{(nwalkers)}
  \hlstd{burn.in} \hlkwb{<-} \hlkwd{as.integer}\hlstd{(burn.in)}

  \hlcom{# number of interations needed}
  \hlstd{nrows.keep} \hlkwb{<-} \hlkwd{ceiling}\hlstd{(nsteps} \hlopt{/} \hlstd{nwalkers)}
  \hlkwa{if} \hlstd{(nrows.keep} \hlopt{<} \hlnum{10}\hlstd{)} \hlkwd{stop}\hlstd{(}\hlstr{'Make nsteps larger'}\hlstd{)}
  \hlstd{nrows.burnin} \hlkwb{<-} \hlkwd{ceiling}\hlstd{(burn.in} \hlopt{/} \hlstd{nwalkers)}
  \hlstd{ncycles} \hlkwb{<-} \hlstd{nrows.keep} \hlopt{+} \hlstd{nrows.burnin}

  \hlcom{# the scale factor is used to define the variance of each variable and is only}
  \hlcom{# used for randomising their starting values}
  \hlkwa{if} \hlstd{(}\hlkwd{is.null}\hlstd{(scale.init)) scale.init} \hlkwb{<-} \hlkwd{rep}\hlstd{(}\hlnum{1e-4}\hlstd{, M)}
  \hlkwa{if} \hlstd{(}\hlkwd{length}\hlstd{(scale.init)} \hlopt{!=} \hlstd{M)} \hlkwd{stop}\hlstd{(}\hlstr{'scale.init has wrong length'}\hlstd{)}
  \hlkwa{if} \hlstd{(}\hlkwd{min}\hlstd{(scale.init} \hlopt{<=} \hlnum{0}\hlstd{))} \hlkwd{stop}\hlstd{(}\hlstr{'scale.init should be >0 everywhere.'}\hlstd{)}

  \hlcom{# check the parameter that sets the size of the random jumps}
  \hlstd{atune} \hlkwb{<-} \hlkwd{as.numeric}\hlstd{(atune)}
  \hlkwa{if} \hlstd{(atune} \hlopt{<=} \hlnum{1}\hlstd{)} \hlkwd{stop}\hlstd{(}\hlstr{'Parameter atune should be >1.'}\hlstd{)}

  \hlcom{# set the size of the complementary sample}
  \hlkwa{if} \hlstd{(}\hlkwd{is.null}\hlstd{(stune)) stune} \hlkwb{<-} \hlkwd{as.integer}\hlstd{( M}\hlopt{+}\hlnum{1} \hlstd{)}
  \hlkwa{if} \hlstd{(}\hlopt{!}\hlkwd{is.integer}\hlstd{(stune))} \hlkwd{warning}\hlstd{(}\hlstr{'stune is not an integer.'}\hlstd{)}

  \hlcom{# initialise the array for output. There are two additional 'columns': The M+1}
  \hlcom{# column stores the accept/reject flag (0=rejected, 1=accepted proposal at }
  \hlcom{# each update). This is useful for tracking the acceptance rate. The M+2 }
  \hlcom{# column stores the log posterior (PDF) values at the current position of the }
  \hlcom{# walker. This saves recomputing the posterior density at the current position}
  \hlcom{# when evaluating the accept probability.}
  \hlstd{theta} \hlkwb{<-} \hlkwd{array}\hlstd{(}\hlnum{NA}\hlstd{,} \hlkwc{dim}\hlstd{=}\hlkwd{c}\hlstd{(ncycles, nwalkers, M}\hlopt{+}\hlnum{2}\hlstd{))}

  \hlcom{# initialise each walker with a slightly different position. The starting }
  \hlcom{# positions are randomised using a M-dimensional t distribution centred on }
  \hlcom{# theta.0. If a matrix cov.init is supplied then use this as the covariance }
  \hlcom{# matrix. Otherwise create a diagonal covariance matrix and set the variances }
  \hlcom{# to be a small fraction (scale.init) of the (absolute value of) the start }
  \hlcom{# position for each variable. If the starting position is exactly zero then }
  \hlcom{# use 1E-6 instead.}
  \hlstd{vars} \hlkwb{<-} \hlstd{scale.init} \hlopt{*} \hlstd{theta.0}\hlopt{^}\hlnum{2}
  \hlstd{vars} \hlkwb{<-} \hlkwd{pmax}\hlstd{(vars,} \hlnum{1E-13}\hlstd{)}
  \hlstd{cov} \hlkwb{<-} \hlkwd{diag}\hlstd{(vars)}
  \hlkwa{if} \hlstd{(}\hlkwd{is.matrix}\hlstd{(cov.init)) cov} \hlkwb{<-} \hlstd{cov.init}
  \hlstd{theta.now} \hlkwb{<-} \hlstd{mvtnorm}\hlopt{::}\hlkwd{rmvnorm}\hlstd{(nwalkers,} \hlkwc{mean}\hlstd{=theta.0,} \hlkwc{sigma}\hlstd{=cov)}

  \hlcom{# add two extra columns to track: the acceptances, the log posterior densities}
  \hlstd{theta.now} \hlkwb{<-} \hlkwd{cbind}\hlstd{(theta.now,} \hlkwd{rep}\hlstd{(}\hlnum{NA}\hlstd{, nwalkers),} \hlkwd{rep}\hlstd{(}\hlnum{NA}\hlstd{, nwalkers))}

  \hlcom{# to get the calculation started, evaluate the posterior density at}
  \hlcom{# these starting positions}
  \hlkwa{for} \hlstd{(i} \hlkwa{in} \hlnum{1}\hlopt{:}\hlstd{nwalkers) \{}
    \hlstd{theta.now[i, M}\hlopt{+}\hlnum{2}\hlstd{]} \hlkwb{<-} \hlkwd{posterior}\hlstd{(theta.now[i,} \hlnum{1}\hlopt{:}\hlstd{M], ...)}
  \hlstd{\}}
  \hlkwa{if} \hlstd{(}\hlopt{!}\hlkwd{all}\hlstd{(}\hlkwd{is.finite}\hlstd{(theta.now[,M}\hlopt{+}\hlnum{2}\hlstd{]))) \{}
    \hlkwd{print}\hlstd{(theta.now[,}\hlnum{1}\hlopt{:}\hlstd{M])}
    \hlkwd{print}\hlstd{(theta.now[,M}\hlopt{+}\hlnum{2}\hlstd{])}
    \hlkwd{stop}\hlstd{(}\hlstr{'Non-finite start values for target PDF.'}\hlstd{)}
  \hlstd{\}}

  \hlcom{# Now, theta.now is a 2D array with dimensions nwalkers * M+2.}
  \hlcom{# each row is the current position of one walker, i.e. an}
  \hlcom{# M-dimensional vector (plus the accept/reject flag, and the log(PDF)).}
  \hlkwa{if} \hlstd{(chatter} \hlopt{>} \hlnum{1}\hlstd{) \{}
    \hlkwd{cat}\hlstd{(}\hlstr{'-- Dimensions of theta.now array:'}\hlstd{,} \hlkwd{dim}\hlstd{(theta.now),} \hlkwc{fill}\hlstd{=}\hlnum{TRUE}\hlstd{)}
    \hlkwd{cat}\hlstd{(}\hlstr{'-- Dimensions of theta array:    '}\hlstd{,} \hlkwd{dim}\hlstd{(theta),} \hlkwc{fill}\hlstd{=}\hlnum{TRUE}\hlstd{)}
    \hlkwd{cat}\hlstd{(}\hlstr{'-- Number of whole cycles:       '}\hlstd{, ncycles,} \hlkwc{fill}\hlstd{=}\hlnum{TRUE}\hlstd{)}
    \hlkwd{cat}\hlstd{(}\hlstr{'-- No. burn-in cycles:           '}\hlstd{, nrows.burnin,} \hlkwc{fill}\hlstd{=}\hlnum{TRUE}\hlstd{)}
  \hlstd{\}}

  \hlcom{# record the start time of the main loop}
  \hlstd{start.time} \hlkwb{<-} \hlkwd{proc.time}\hlstd{()}

  \hlcom{# main loop over ncycles, each iteration updates all walkers }
  \hlcom{# the first (burn.in) steps are the 'burn-in' period}
  \hlkwa{for} \hlstd{(i} \hlkwa{in} \hlnum{1}\hlopt{:}\hlstd{ncycles) \{}

    \hlcom{# should we to a "stretch" (default) or a "walk" move?}
    \hlstd{do.walk} \hlkwb{<-} \hlnum{FALSE}
    \hlkwa{if} \hlstd{(walk.rate} \hlopt{>} \hlnum{0}\hlstd{) \{}
      \hlstd{do.walk} \hlkwb{<-} \hlstd{(i} \hlopt{%%} \hlstd{walk.rate} \hlopt{==} \hlnum{0}\hlstd{)}
    \hlstd{\}}

    \hlcom{# update the walkers' position to step i using their positions}
    \hlcom{# at step i-1}
    \hlkwa{if} \hlstd{(do.walk} \hlopt{==} \hlnum{TRUE}\hlstd{) \{}
      \hlstd{theta.now} \hlkwb{<-} \hlkwd{walk.move}\hlstd{(posterior, theta.now,}
                             \hlkwc{chatter} \hlstd{= chatter, stune, ...)}
    \hlstd{\}} \hlkwa{else} \hlstd{\{}
      \hlstd{theta.now} \hlkwb{<-} \hlkwd{stretch.move}\hlstd{(posterior, theta.now,}
                                \hlkwc{chatter} \hlstd{= chatter, atune, ...)}
    \hlstd{\}}

    \hlcom{# safety check}
    \hlkwa{if} \hlstd{(}\hlopt{!}\hlkwd{all}\hlstd{(}\hlkwd{is.finite}\hlstd{(theta.now[, M}\hlopt{+}\hlnum{2}\hlstd{]))) \{}
      \hlstd{mask} \hlkwb{<-} \hlopt{!}\hlkwd{is.finite}\hlstd{(theta.now[, M}\hlopt{+}\hlnum{2}\hlstd{])}
      \hlkwd{cat}\hlstd{(theta.now[mask,])}
      \hlkwd{stop}\hlstd{(}\hlstr{'Non-finite value in theta.now.'}\hlstd{)}
    \hlstd{\}}

    \hlcom{# save the current position of each walker}
    \hlstd{theta[i, , ]} \hlkwb{<-} \hlstd{theta.now}

    \hlcom{# progress report to user if requested}
      \hlstd{i.count} \hlkwb{<-} \hlnum{1}
      \hlkwa{if} \hlstd{(chatter} \hlopt{>} \hlnum{0}\hlstd{) \{}
      \hlkwa{if} \hlstd{(i} \hlopt{%%} \hlstd{update} \hlopt{==} \hlnum{0}\hlstd{) \{}
        \hlstd{accept.rate} \hlkwb{<-} \hlkwd{mean}\hlstd{( theta[i.count}\hlopt{:}\hlstd{i,,M}\hlopt{+}\hlnum{1}\hlstd{],} \hlkwc{na.rm}\hlstd{=}\hlnum{TRUE} \hlstd{)}
        \hlkwd{cat}\hlstd{(}\hlstr{"\textbackslash{}r-- Cycle"}\hlstd{, i,} \hlstr{"of"}\hlstd{, ncycles,} \hlstr{". Acceptance rate:"}\hlstd{,}
            \hlkwd{signif}\hlstd{(accept.rate}\hlopt{*}\hlnum{100}\hlstd{,} \hlnum{2}\hlstd{),} \hlstr{"%"}\hlstd{)}
      \hlstd{\}}
      \hlkwa{if} \hlstd{(i} \hlopt{==} \hlstd{ncycles)} \hlkwd{cat}\hlstd{(}\hlstr{''}\hlstd{,} \hlkwc{fill}\hlstd{=}\hlnum{TRUE}\hlstd{)}
      \hlkwa{if} \hlstd{(i} \hlopt{==} \hlstd{nrows.burnin) \{}
        \hlkwd{cat}\hlstd{(}\hlstr{' - Finished burn-in'}\hlstd{,} \hlkwc{fill}\hlstd{=}\hlnum{TRUE}\hlstd{)}
        \hlstd{i.count} \hlkwb{<-} \hlstd{nrows.burnin}\hlopt{+}\hlnum{1}
      \hlstd{\}}
    \hlstd{\}}
  \hlstd{\}} \hlcom{# end of main loop (i = 1, ncycles)}

  \hlcom{# record the end time of the main loop}
  \hlstd{end.time} \hlkwb{<-} \hlkwd{proc.time}\hlstd{()}

  \hlcom{# strip off the burn-in period and keep only nsteps }
  \hlstd{nrows} \hlkwb{<-} \hlstd{nrows.keep}
  \hlstd{theta} \hlkwb{<-} \hlstd{theta[(}\hlnum{1}\hlopt{:}\hlstd{nrows)} \hlopt{+} \hlstd{nrows.burnin, , ]}

  \hlcom{# thin the output by keeping only every few rows}
  \hlkwa{if} \hlstd{(}\hlopt{!}\hlkwd{is.null}\hlstd{(thin)) \{}
    \hlstd{nrow.keep} \hlkwb{<-} \hlkwd{floor}\hlstd{(nrows} \hlopt{/} \hlstd{thin)}
    \hlstd{mask} \hlkwb{<-} \hlstd{(}\hlnum{1}\hlopt{:}\hlstd{nrow.keep)} \hlopt{*} \hlstd{thin}
    \hlstd{theta} \hlkwb{<-} \hlstd{theta[mask,,]}
  \hlstd{\}}

  \hlcom{# Strip off the acceptance and log(posterior) columns }
  \hlstd{accept} \hlkwb{<-} \hlstd{theta[, , M}\hlopt{+}\hlnum{1}\hlstd{]}
  \hlstd{lpost} \hlkwb{<-} \hlkwd{as.vector}\hlstd{( theta[, , M}\hlopt{+}\hlnum{2}\hlstd{])}
  \hlstd{theta} \hlkwb{<-} \hlstd{theta[, ,} \hlnum{1}\hlopt{:}\hlstd{M]}

  \hlcom{# check the acceptance rate (column M+1).}
  \hlcom{# Also strip off the log(posterior) values which are no longer needed.}
  \hlstd{accept.rate} \hlkwb{<-} \hlkwd{mean}\hlstd{(accept,} \hlkwc{na.rm} \hlstd{=} \hlnum{TRUE}\hlstd{)}
  \hlkwa{if} \hlstd{(chatter} \hlopt{>} \hlnum{0}\hlstd{) \{}
    \hlkwd{print}\hlstd{(end.time} \hlopt{-} \hlstd{start.time)}
    \hlkwd{cat}\hlstd{(}\hlstr{'\textbackslash{}n-- Final acceptance rate: '}\hlstd{, accept.rate,} \hlkwc{fill} \hlstd{=} \hlnum{TRUE}\hlstd{)}
    \hlkwa{if} \hlstd{(accept.rate} \hlopt{<} \hlnum{0.05}\hlstd{) \{}
      \hlkwd{cat}\hlstd{(}\hlstr{'-- Low acceptance rate. Consider the following suggestions:'}\hlstd{,}
          \hlkwc{fill} \hlstd{=} \hlnum{TRUE}\hlstd{)}
      \hlkwd{cat}\hlstd{(}\hlstr{'-- 1. Increase number of walkers: nwalkers.'}\hlstd{,} \hlkwc{fill} \hlstd{=} \hlnum{TRUE}\hlstd{)}
      \hlkwd{cat}\hlstd{(}\hlstr{'-- 2. Lower the jump scale parameter: atune.'}\hlstd{,} \hlkwc{fill} \hlstd{=} \hlnum{TRUE}\hlstd{)}
      \hlkwd{cat}\hlstd{(}\hlstr{'-- 3. Adjust the start position: theta.0,'}\hlstd{,} \hlkwc{fill} \hlstd{=} \hlnum{TRUE}\hlstd{)}
      \hlkwd{cat}\hlstd{(}\hlstr{'-- 4. increasing the variances of the start point 
           randomisation: scale.init or cov.init.'}\hlstd{,} \hlkwc{fill} \hlstd{=} \hlnum{TRUE}
      \hlstd{)}
    \hlstd{\}}
  \hlstd{\}}

  \hlcom{# reshape the array from [nrows, M, nwalkers] to [nrows*nwalkers, M]}
  \hlcom{# so each column is one variable, each row is one sample from the M}
  \hlcom{# M-dimensional distribution.}
  \hlkwa{if} \hlstd{(merge.walkers} \hlopt{==} \hlnum{TRUE}\hlstd{) \{}
    \hlstd{nrows} \hlkwb{<-} \hlkwd{dim}\hlstd{(theta)[}\hlnum{1}\hlstd{]}
    \hlstd{theta} \hlkwb{<-} \hlkwd{matrix}\hlstd{(theta,} \hlkwc{nrow} \hlstd{= nwalkers} \hlopt{*} \hlstd{nrows,} \hlkwc{ncol} \hlstd{= M,} \hlkwc{byrow} \hlstd{=} \hlnum{FALSE}\hlstd{)}
  \hlstd{\}}

  \hlcom{# return the final array}
  \hlkwd{return}\hlstd{(}\hlkwd{list}\hlstd{(}\hlkwc{theta} \hlstd{= theta,}
              \hlkwc{func} \hlstd{=} \hlkwd{deparse}\hlstd{(}\hlkwd{substitute}\hlstd{(posterior)),}
              \hlkwc{lpost} \hlstd{= lpost,}
              \hlkwc{method} \hlstd{=} \hlstr{"gw.mcmc"}\hlstd{,}
              \hlkwc{nwalkers} \hlstd{= nwalkers))}
\hlstd{\}}
\end{alltt}
\end{kframe}
\end{knitrout}
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{# stretch.move - update an ensemble of 'walkers' using the 'stretch move'}
\hlcom{#}
\hlcom{# Inputs: }
\hlcom{#   posterior  - (function) name of the log(posterior) function to sample from}
\hlcom{#   theta      - (array) nwalkers (rows) * M+2 (columns) }
\hlcom{#                  the current position of each walker}
\hlcom{#   a          - (float) set the scale size of the random jumps }
\hlcom{#   ...        - (anything else) any other arguments needed for posterior }
\hlcom{#}
\hlcom{# Value:}
\hlcom{#   theta     - (array) nwalkers (rows) * M+2 (columns) }
\hlcom{#                  updated position of each walker}
\hlcom{#}
\hlcom{# Description: }
\hlcom{# A simple implementation of the ensemble MCMC sampler proposed by Goodman &}
\hlcom{# Weare (2010). Given some function to compute the log of an (un-normalised)}
\hlcom{# M-dimensional posterior density function (PDF) this will produce <nsteps>}
\hlcom{# samples of M-dimensional vectors drawn from the PDF.}
\hlcom{# }
\hlcom{# At input the array <theta> gives the current position of each walker. There }
\hlcom{# are <nwalkers> rows, one for each walker. Each row has M+2 columns. The first }
\hlcom{# 1:M columns are the position of each walker, an M-dimensional vector. On }
\hlcom{# output the position of each walker is updated. And the M+1 column is assigned }
\hlcom{# 0 (rejected) or 1 (accepted) depending on whether the walkers' position is }
\hlcom{# updated this cycle (accept/reject the proposed update position). The M+2 }
\hlcom{# column contains the log(posterior density) at the walkers' current position }
\hlcom{# (after update).}
\hlcom{# }
\hlcom{# Each walkers' position is updated in turn. The position of walker j is updated}
\hlcom{# by randomly selecting another walker k from the ensemble (the complementary }
\hlcom{# walker) and moving along the line joining the current position of walker j to }
\hlcom{# walker k. The jump size is random and has the distribution suggested by }
\hlcom{# Goodman & Weare (eqn 9). This updated position for walker i is then accepted }
\hlcom{# or rejected with a probability that depends on the ratio of the posterior }
\hlcom{# densities at the current and the proposed new position. If the proposal is }
\hlcom{# rejected, walker j remains at its current position. Once every walker has been}
\hlcom{# updated (j = 1, 2, ..., nwalkers) we move to cycle i+1 and repeat the update }
\hlcom{# step.}
\hlcom{# }
\hlcom{# The random numbers (the size of the jump z and the uniform variate u used to }
\hlcom{# randomly choose accept/reject) are computed before the loop over walkers }
\hlcom{# begins. This is to make the code a little more clear and efficient.}
\hlcom{# }
\hlcom{# History:}
\hlcom{#  04/04/16 - First working version}
\hlcom{#}
\hlcom{# Simon Vaughan, University of Leicester}
\hlcom{# Copyright (C) 2016 Simon Vaughan}
\end{alltt}
\end{kframe}
\end{knitrout}
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{stretch.move} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{posterior}\hlstd{,} \hlkwc{theta}\hlstd{,} \hlkwc{a}\hlstd{,} \hlkwc{chatter}\hlstd{=}\hlnum{0}\hlstd{,} \hlkwc{...}\hlstd{) \{}

  \hlcom{# number of walkers to treat}
  \hlstd{nwalkers} \hlkwb{<-} \hlkwd{NROW}\hlstd{(theta)}

  \hlcom{# number of dimensions of each walker}
  \hlstd{M} \hlkwb{<-} \hlkwd{as.integer}\hlstd{(} \hlkwd{NCOL}\hlstd{(theta)}\hlopt{-}\hlnum{2} \hlstd{)}

  \hlcom{# an index of walkers}
  \hlstd{walkers} \hlkwb{<-} \hlnum{1}\hlopt{:}\hlstd{nwalkers}

  \hlcom{# draw the random z values and u values}
  \hlcom{# The z density is eqn 9 of Goodman & Weare (2010)}
  \hlstd{z} \hlkwb{<-} \hlstd{(}\hlnum{1}\hlopt{/}\hlstd{a)} \hlopt{*} \hlstd{(} \hlnum{1} \hlopt{+} \hlstd{(a}\hlopt{-}\hlnum{1}\hlstd{)}\hlopt{*}\hlkwd{runif}\hlstd{(nwalkers) )}\hlopt{^}\hlnum{2}
  \hlstd{u} \hlkwb{<-} \hlkwd{runif}\hlstd{(nwalkers)}

  \hlcom{# loop over each walker, updating its position}
  \hlkwa{for} \hlstd{(j} \hlkwa{in} \hlnum{1}\hlopt{:}\hlstd{nwalkers) \{}

    \hlcom{# for walker j, randomly select a complementary walker k}
    \hlstd{k} \hlkwb{<-} \hlkwd{sample}\hlstd{(walkers[}\hlopt{-}\hlstd{j],} \hlnum{1}\hlstd{)}

    \hlcom{# present position of the jth walker}
    \hlstd{X.pres} \hlkwb{<-} \hlstd{theta[j,} \hlnum{1}\hlopt{:}\hlstd{M]}

    \hlcom{# present position of the complementary (kth) walker}
    \hlstd{X.comp} \hlkwb{<-} \hlstd{theta[k,} \hlnum{1}\hlopt{:}\hlstd{M]}

    \hlcom{# proposed new position for the jth walker}
    \hlcom{# This is eqn 7 of Goodman & Weare (2010)}
    \hlstd{X.prop} \hlkwb{<-} \hlstd{(}\hlnum{1}\hlopt{-}\hlstd{z[j])}\hlopt{*}\hlstd{X.comp} \hlopt{+} \hlstd{z[j]}\hlopt{*}\hlstd{X.pres}

    \hlcom{# evalute the log PDF at the current and proposed positions.}
    \hlcom{# The value at the current position was evaluated in the previous}
    \hlcom{# step, so we reuse this value. Only the value at the proposed new}
    \hlcom{# position needs evaluating.}
    \hlstd{p.pres} \hlkwb{<-} \hlstd{theta[j, M}\hlopt{+}\hlnum{2}\hlstd{]}
    \hlstd{p.prop} \hlkwb{<-} \hlkwd{posterior}\hlstd{(X.prop, ...)}

    \hlcom{# now evaluate the acceptance probability}
    \hlstd{logP} \hlkwb{<-} \hlstd{(M}\hlopt{-}\hlnum{1}\hlstd{)}\hlopt{*}\hlkwd{log}\hlstd{(z[j])} \hlopt{+} \hlstd{p.prop} \hlopt{-} \hlstd{p.pres}
    \hlstd{lopP} \hlkwb{<-} \hlkwd{max}\hlstd{(logP,} \hlnum{0}\hlstd{)}
    \hlkwa{if} \hlstd{(} \hlkwd{exp}\hlstd{(logP)} \hlopt{>=} \hlstd{u[j] ) \{}
      \hlstd{theta[j,} \hlnum{1}\hlopt{:}\hlstd{M]} \hlkwb{<-} \hlstd{X.prop}     \hlcom{# accept}
      \hlstd{theta[j, M}\hlopt{+}\hlnum{1}\hlstd{]} \hlkwb{<-} \hlnum{1}
      \hlstd{theta[j, M}\hlopt{+}\hlnum{2}\hlstd{]} \hlkwb{<-} \hlstd{p.prop}
    \hlstd{\}} \hlkwa{else} \hlstd{\{}
      \hlstd{theta[j,} \hlnum{1}\hlopt{:}\hlstd{M]} \hlkwb{<-} \hlstd{X.pres}     \hlcom{# reject}
      \hlstd{theta[j, M}\hlopt{+}\hlnum{1}\hlstd{]} \hlkwb{<-} \hlnum{0}
      \hlstd{theta[j, M}\hlopt{+}\hlnum{2}\hlstd{]} \hlkwb{<-} \hlstd{p.pres}
    \hlstd{\}}

  \hlstd{\}} \hlcom{# end of loop (j = 1, nwalkers)}

  \hlkwa{if} \hlstd{(chatter} \hlopt{>} \hlnum{5}\hlstd{) \{}
    \hlkwd{cat}\hlstd{(}\hlstr{'-- Sretch move accept rate:'}\hlstd{,} \hlkwd{mean}\hlstd{(theta[,M}\hlopt{+}\hlnum{1}\hlstd{]))}
  \hlstd{\}}

  \hlcom{# return the updated array }
  \hlkwd{return}\hlstd{(theta)}

\hlstd{\}}
\end{alltt}
\end{kframe}
\end{knitrout}
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcom{# walk - update an ensemble of 'walkers' using the 'walk move'}
\hlcom{#}
\hlcom{# Inputs: }
\hlcom{#   theta      - (array) nwalkers (rows) * M+2 (columns) current position }
\hlcom{#                   of each walker}
\hlcom{#   S          - (integer) size of the complementary sample }
\hlcom{#   posterior  - (function) name of the log(posterior) function we are }
\hlcom{#                   sampling from}
\hlcom{#   ...        - (anything else) any other arguments needed for the }
\hlcom{#                   posterior function}
\hlcom{#}
\hlcom{# Value:}
\hlcom{#   theta     - (array) nwalkers (rows) * M+2 (columns) updated position }
\hlcom{#                 of each walker}
\hlcom{#}
\hlcom{# Description:}
\hlcom{# A simple implementation of the ensemble MCMC sampler proposed by Goodman &}
\hlcom{# Weare (2010). Given some function to compute the log of an (un-normalised)}
\hlcom{# M-dimensional posterior density function (PDF) this will produce <nsteps>}
\hlcom{# samples of M-dimensional vectors drawn from the PDF.}
\hlcom{# }
\hlcom{# At input the array <theta> gives the current position of each walker. There}
\hlcom{# are <nwalkers> rows, one for each walker. Each row has M+2 columns. The first}
\hlcom{# 1:M columns are the position of each walker, an M-dimensional vector. On}
\hlcom{# output the position of each walker is updated. And the M+1 column is assigned}
\hlcom{# 0 (rejected) or 1 (accepted) depending on whether the walkers' position is}
\hlcom{# updated this cycle (accept/reject the proposed update position). The M+2}
\hlcom{# column contains the log(posterior density) at the walkers' current position}
\hlcom{# (after update).}
\hlcom{# }
\hlcom{# Each walkers' position is updated in turn. The position of walker j is updated}
\hlcom{# by randomly selecting a subset of walkers from the ensemble (the complementary}
\hlcom{# sample). From the sample we effectively compute the covariance matrix, and use}
\hlcom{# this to define a multivariate Normal, with the mean as the current position of}
\hlcom{# walker j. We then propose a new position for walker j by drawing from this }
\hlcom{# multivariate Normal.}
\hlcom{# }
\hlcom{# In practice we randomly select M+1 walkers' positions (where M is the number}
\hlcom{# of variables, or dimensions of the problem), from the set of all walkers}
\hlcom{# excluding walker j. With M+1 positions we form a 'simplex'. (Although, by}
\hlcom{# setting the S parameter one can increase the size of the complementary sample}
\hlcom{# if desired, forming an S-polytope.) We then compute the mean position of the}
\hlcom{# complementary sample <x> and the displacements of each of its walkers from}
\hlcom{# this mean: delta_k = (x_k - <x>). We then produce M+1 univariate, Normal }
\hlcom{# random numbers z_k and compute W = sum_k z_k * delta_k. So W is a random}
\hlcom{# displacement made from a weighted sum of the displacements (of each walker in}
\hlcom{# the complementary sample from their mean), with random weights. (See Goodman &}
\hlcom{# Weare eqn 11.)}
\hlcom{# }
\hlcom{# This updated position for walker i is then accepted or rejected with a}
\hlcom{# probability that depends on the ratio of the posterior densities at the}
\hlcom{# current and the proposed new position. If the proposal is rejected, walker j}
\hlcom{# remains at its current position. Once every walker has been updated (j = 1, 2,}
\hlcom{# ..., nwalkers) we move to cycle i+1 and repeat the update step.}
\hlcom{# }
\hlcom{# The random numbers (the size of the jump z and the uniform variate u used to}
\hlcom{# randomly choose accept/reject) are computed before the loop over walkers}
\hlcom{# begins. This is to make the code a little more clear and efficient.}
\hlcom{#}
\hlcom{# History:}
\hlcom{#  14/04/16 - First working version}
\hlcom{#}
\hlcom{# Simon Vaughan, University of Leicester}
\hlcom{# Copyright (C) 2016 Simon Vaughan}
\end{alltt}
\end{kframe}
\end{knitrout}
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlstd{walk.move} \hlkwb{<-} \hlkwa{function}\hlstd{(}\hlkwc{posterior}\hlstd{,} \hlkwc{theta}\hlstd{,} \hlkwc{S}\hlstd{=}\hlkwa{NULL}\hlstd{,} \hlkwc{chatter}\hlstd{=}\hlnum{0}\hlstd{,} \hlkwc{...}\hlstd{) \{}

  \hlcom{# number of walkers to treat}
  \hlstd{nwalkers} \hlkwb{<-} \hlkwd{NROW}\hlstd{(theta)}

  \hlcom{# number of dimensions of each walker}
  \hlstd{M} \hlkwb{<-} \hlkwd{as.integer}\hlstd{(} \hlkwd{NCOL}\hlstd{(theta)}\hlopt{-}\hlnum{2} \hlstd{)}

  \hlcom{# set the size of the complementary sample}
  \hlcom{# should be M < S < nwalkers}
  \hlkwa{if} \hlstd{(}\hlkwd{is.null}\hlstd{(S)) S} \hlkwb{<-} \hlstd{M}\hlopt{+}\hlnum{1}
  \hlkwa{if} \hlstd{(S} \hlopt{<=} \hlstd{M) S} \hlkwb{<-} \hlstd{M}\hlopt{+}\hlnum{1}
  \hlkwa{if} \hlstd{(S} \hlopt{>=} \hlstd{nwalkers) S} \hlkwb{<-} \hlstd{nwalkers} \hlopt{-} \hlnum{1}
  \hlstd{S} \hlkwb{<-} \hlkwd{as.integer}\hlstd{(S)}

  \hlcom{# an index of walkers}
  \hlstd{walkers} \hlkwb{<-} \hlnum{1}\hlopt{:}\hlstd{nwalkers}

  \hlcom{# draw the random z values and u values}
  \hlcom{# u are uniform values (0-1) and z are standard normal values}
  \hlcom{# for each walker we need S values of z.}
  \hlstd{z} \hlkwb{<-} \hlkwd{array}\hlstd{(}\hlkwd{rnorm}\hlstd{(nwalkers} \hlopt{*} \hlstd{S),} \hlkwc{dim}\hlstd{=}\hlkwd{c}\hlstd{(nwalkers, S))}
  \hlstd{u} \hlkwb{<-} \hlkwd{runif}\hlstd{(nwalkers)}

  \hlcom{# loop over each walker, updating its position}
  \hlkwa{for} \hlstd{(j} \hlkwa{in} \hlnum{1}\hlopt{:}\hlstd{nwalkers) \{}

    \hlcom{# for walker j, randomly select a complementary sample of S walkers}
    \hlstd{s} \hlkwb{<-} \hlkwd{sample}\hlstd{(walkers[}\hlopt{-}\hlstd{j], S,} \hlkwc{replace}\hlstd{=}\hlnum{FALSE}\hlstd{)}

    \hlcom{# current position of the jth walker}
    \hlstd{X.pres} \hlkwb{<-} \hlstd{theta[j,} \hlnum{1}\hlopt{:}\hlstd{M]}

    \hlcom{# current positions of all S of the complementary walkers}
    \hlcom{# X.comp is a [S, M] matrix; each row is position of one walker}
    \hlstd{X.comp} \hlkwb{<-} \hlstd{theta[s,} \hlnum{1}\hlopt{:}\hlstd{M]}

    \hlcom{# find mean position of the complementary walkers}
    \hlcom{# X.mean is an M-vector}
    \hlstd{X.mean} \hlkwb{<-} \hlkwd{apply}\hlstd{(X.comp,} \hlnum{2}\hlstd{, mean)}

    \hlcom{# find deviation of each complementary walker from their mean}
    \hlcom{# delta.k is a [S, M] matrix; each row is difference of a walker }
    \hlcom{# from the mean}
    \hlstd{delta.k} \hlkwb{<-} \hlstd{X.comp} \hlopt{-} \hlstd{X.mean[}\hlkwd{col}\hlstd{(X.comp)]}

    \hlcom{# randomly weight each deviation}
    \hlcom{# W.k is a matrix; each row is a randomly weighted difference}
    \hlcom{# (Using 'recyling' we get each row (walker difference) multiplied by}
    \hlcom{# one random deviate from z.)}
    \hlstd{W.k} \hlkwb{<-} \hlstd{z[j, ]} \hlopt{*} \hlstd{delta.k}

    \hlcom{# now compute the random step W from the sum of all the deviations}
    \hlcom{# (Sum over all the delta.k's to get an M-vector.)}
    \hlcom{# This is eqn 11 of Goodman & Weare except I correct it by }
    \hlcom{# a factor 1/sqrt(N) to ensure the covarince matrix is as required.}
    \hlstd{W} \hlkwb{<-} \hlkwd{apply}\hlstd{(W.k,} \hlnum{2}\hlstd{, sum)} \hlopt{/} \hlkwd{sqrt}\hlstd{(S)}

    \hlcom{# proposed new position for the jth walker}
    \hlstd{X.prop} \hlkwb{<-} \hlstd{X.pres} \hlopt{+} \hlstd{W}

    \hlkwa{if} \hlstd{(chatter} \hlopt{>} \hlnum{10}\hlstd{) \{}
      \hlkwd{cat}\hlstd{(}\hlstr{'-- X.pres'}\hlstd{, X.pres,} \hlkwc{fill}\hlstd{=}\hlnum{TRUE}\hlstd{)}
      \hlkwd{cat}\hlstd{(}\hlstr{'-- X.mean'}\hlstd{, X.mean,} \hlkwc{fill}\hlstd{=}\hlnum{TRUE}\hlstd{)}
      \hlkwd{cat}\hlstd{(}\hlstr{'-- W'}\hlstd{, W,} \hlkwc{fill}\hlstd{=}\hlnum{TRUE}\hlstd{)}
      \hlkwd{cat}\hlstd{(}\hlstr{'-- X.prop'}\hlstd{, X.prop,} \hlkwc{fill}\hlstd{=}\hlnum{TRUE}\hlstd{)}
      \hlkwd{cat}\hlstd{(}\hlstr{'-- subsample'}\hlstd{, s,} \hlkwc{fill}\hlstd{=}\hlnum{TRUE}\hlstd{)}
\hlcom{#      cat('-- stune', S, fill=TRUE)}
    \hlstd{\}}

    \hlcom{# evalute the log PDF at the existing and proposed positions.}
    \hlcom{# The value at the current position was evaluated in the previous}
    \hlcom{# step, so we reuse this value. Only the value at the proposed new}
    \hlcom{# position needs evaluating.}
    \hlstd{p.pres} \hlkwb{<-} \hlstd{theta[j, M}\hlopt{+}\hlnum{2}\hlstd{]}
    \hlstd{p.prop} \hlkwb{<-} \hlkwd{posterior}\hlstd{(X.prop, ...)}

    \hlcom{# now evaluate the acceptance probability}
    \hlstd{logP} \hlkwb{<-} \hlstd{p.prop} \hlopt{-} \hlstd{p.pres}
    \hlstd{lopP} \hlkwb{<-} \hlkwd{max}\hlstd{(logP,} \hlnum{0}\hlstd{)}
    \hlkwa{if} \hlstd{(} \hlkwd{exp}\hlstd{(logP)} \hlopt{>=} \hlstd{u[j] ) \{}
      \hlstd{theta[j,} \hlnum{1}\hlopt{:}\hlstd{M]} \hlkwb{<-} \hlstd{X.prop}     \hlcom{# accept}
      \hlstd{theta[j, M}\hlopt{+}\hlnum{1}\hlstd{]} \hlkwb{<-} \hlnum{1}
      \hlstd{theta[j, M}\hlopt{+}\hlnum{2}\hlstd{]} \hlkwb{<-} \hlstd{p.prop}
    \hlstd{\}} \hlkwa{else} \hlstd{\{}
      \hlstd{theta[j,} \hlnum{1}\hlopt{:}\hlstd{M]} \hlkwb{<-} \hlstd{X.pres}     \hlcom{# reject}
      \hlstd{theta[j, M}\hlopt{+}\hlnum{1}\hlstd{]} \hlkwb{<-} \hlnum{0}
      \hlstd{theta[j, M}\hlopt{+}\hlnum{2}\hlstd{]} \hlkwb{<-} \hlstd{p.pres}
    \hlstd{\}}

  \hlstd{\}} \hlcom{# end of loop (j = 1, nwalkers)}

  \hlkwa{if} \hlstd{(chatter} \hlopt{>} \hlnum{5}\hlstd{) \{}
    \hlkwd{cat}\hlstd{(}\hlstr{'-- Walk move accept rate:'}\hlstd{,} \hlkwd{mean}\hlstd{(theta[,M}\hlopt{+}\hlnum{1}\hlstd{]))}
  \hlstd{\}}

  \hlcom{# return the updated array }
  \hlkwd{return}\hlstd{(theta)}

\hlstd{\}}
\end{alltt}
\end{kframe}
\end{knitrout}

The R session information (including the OS info, R version and all
packages used):

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlkwd{sessionInfo}\hlstd{()}
\end{alltt}
\begin{verbatim}
## R version 3.2.2 (2015-08-14)
## Platform: x86_64-w64-mingw32/x64 (64-bit)
## Running under: Windows 8 x64 (build 9200)
## 
## locale:
## [1] LC_COLLATE=English_United Kingdom.1252  LC_CTYPE=English_United Kingdom.1252   
## [3] LC_MONETARY=English_United Kingdom.1252 LC_NUMERIC=C                           
## [5] LC_TIME=English_United Kingdom.1252    
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
## [1] knitr_1.12.3
## 
## loaded via a namespace (and not attached):
## [1] magrittr_1.5  formatR_1.2.1 tools_3.2.2   stringi_1.0-1 highr_0.5.1   stringr_1.0.0
## [7] evaluate_0.8
\end{verbatim}
\begin{alltt}
\hlkwd{Sys.time}\hlstd{()}
\end{alltt}
\begin{verbatim}
## [1] "2016-07-13 08:43:19 BST"
\end{verbatim}
\end{kframe}
\end{knitrout}


\end{document}
