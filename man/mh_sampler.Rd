% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/metropolis.R
\name{mh_sampler}
\alias{mh_sampler}
\title{Random Walk Metropolis-Hastings sampler using multiple chains.}
\usage{
mh_sampler(posterior, theta.0, nsteps = 10000, nchains = 5, burn.in = 10,
  update = 5, chatter = 1, cov = NULL, thin = NULL,
  merge.chains = TRUE, adapt = FALSE, proposal = "normal", ...)
}
\arguments{
\item{posterior}{(function) name of the log(densiy) function to sampling from}

\item{theta.0}{(vector) initial values of the M variables}

\item{nsteps}{(integer) total number of samples required}

\item{nchains}{(integer) number of distinct 'chains' to run.}

\item{burn.in}{(integer) the 'burn-in' period for the walkers}

\item{update}{(integer) print a progress update after \code{update} steps}

\item{chatter}{(integer) how verbose is the output? 
(0=quiet, 1=normal, 2=verbose)}

\item{cov}{(array/matrix) covariance matrix for proposal distribution.}

\item{thin}{(integer) keep only every <thin> sample}

\item{merge.chains}{(logical) combine output from all chains into one}

\item{adapt}{(logical) if \code{TRUE} then adjust the covariance matrix using the 
samples from the burn in period.}

\item{proposal}{(string) Use "normal" proposal, or else "t" distribution.}

\item{...}{(anything else) other arguments needed for posterior function}
}
\value{
A list with components
  \item{theta}{(array) \code{nsteps} samples from M-dimensional posterior [nsteps rows, M columns]}
  \item{func}{(string) name of posterior function sampled}
  \item{lpost}{(vector) nsteps values of the LogPosterior density at each sample position}
  \item{method}{(string) sampling method used ("mh_sampler")}
  \item{nchains}{number of chains used}
If \code{merge.chains = FALSE} then \code{theta} will be a 3D array with
dimensions \code{nchains * (nsteps/nchains) * M}.
}
\description{
\code{mh_sampler} returns posterior samples from a RW-MH sampler.
}
\details{
A simple, pure R function to carry generate MCMC output using the random walk
Metropolis-Hastings algorithm. Uses a Normal or t distribution for the
proposal.
}
\section{Notes}{

Generate samples from some 'target' density function specified by the 
\code{posterior} function. Uses the random walk Metropolis-Hastings
algorithm. The 'proposal' distribution is either a multivariate normal
(default) or a Student's t distribution (with \code{df=3}). The latter has
slightly fatter tails, so might be preferred for non-normal target densities.

This function generates a total of \code{nsteps} samples after a 'burn in'
period of \code{burn.in} steps. Allowing for a burn in period helps remove
memory of the starting position (important if this is not well chosen). We
run \code{nchains} in parallel, from slightly different starting positions.
Each chain only needs to run for \code{nsteps / nchain} iterations (after the
burn in is complete). Having multiple chains helps assess convergence: are
they 'well mixed' meanng that samples from each walker appear to be drawn
from the same distribution? We can examine the moments and histograms of the 
chains to check this.

The proposal density (\code{normal} or \code{t}) requires a covariance
matrix. This is specified on input by the \code{cov} argument. If not
specified this will default to an identity matrix. Chosing a sensible
covariance matrix for the proposal is part of the 'art' of MCMC. If the
proposal is badly chosen - and nothing like the target density - then
convergence (in distribution) will be very slow.

MCMC practitioners often aim for an acceptance rate of 0.1-0.5. If the 
acceptance rate is very low it means there will be many repeats of the same 
values before new ones are accepted, and so the random walk will explore the 
target density slowly. This is usually because the proposal density is too 
large compared to the target density - try reducing the scale of the 
covariance matrix. If the acceptance rate is very high (approaching 100\%) 
then probably the proposal distribution is too small, each new proposed 
position is very close to the current position (and so of similar density and
highly likely to be accepted). Again, this means the random walk will move
only slowly through the target density. In this case, making the covariance
larger usually helps.

The target density function: The target density should is specified by the 
\code{posterior} function. In fact, this function should compute the log
density given parameters theta and any other arguments, i.e. log(p) = 
\code{posterior(theta, ...)} where the vector of parameters \code{theta} is
the first argument of the posterior function. Where the density is zero or
not defined, e.g. because prior = 0 for certain values of the parameters, it 
should return \code{-Inf}. Otherwise, the output of \code{posterior(theta,
...)} should be a real, scalar value.
}

\seealso{
\code{\link{chain_convergence}}, \code{\link{gw_sampler}}
}
